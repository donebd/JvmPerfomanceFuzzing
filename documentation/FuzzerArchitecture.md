# JVM Performance Fuzzer: Архитектура и документация

## 1. Обзор системы

JVM Performance Fuzzer - инструмент для автоматизированного поиска различий в производительности между разными реализациями Java Virtual Machine (OpenJDK, Oracle JVM, GraalVM и др.) с помощью методов мутационного фаззинга байткода. Инструмент генерирует функционально эквивалентные варианты программ на Java, которые теоретически должны иметь одинаковую производительность на всех JVM, но на практике могут выявлять существенные различия из-за особенностей реализации, JIT-оптимизаций и других факторов.

## 2. Ключевые компоненты системы

### 2.1 Источники байткода
- **ByteCodeProvider** - интерфейс для получения исходного байткода
    - **JavaByteCodeProvider** - компилирует Java-код и предоставляет байткод
    - **FileBytecodeProvider** - читает готовый байткод из файла

### 2.2 Цикл фаззинга
- **Fuzzer** - основной компонент, управляющий процессом фаззинга
    - **EvolutionaryFuzzer** - основная реализация
    - Координирует все остальные компоненты
    - Отслеживает различные метрики и управляет циклом фаззинга

- **SeedManager** - управляет популяцией сидов
    - **EnergySeedManager** - основная реализация
    - Реализует энергетическо-ценностную модель эволюции сидов
    - Принимает решения о выборе сидов для мутации
    - Отслеживает энергию и ценность каждого сида
    - Регулирует жизненный цикл сидов в зависимости от результатов

### 2.3 Система мутации
- **Mutator** - выбирает стратегии мутации
    - **AdaptiveMutator** - основная реализация
    - Ведет статистику эффективности стратегий
    - Использует метод "рулетки" для выбора следующей стратегии
    - Обеспечивает баланс между исследованием и использованием

- **JimpleTranslator** - конвертирует байткод в промежуточное представление
    - Использует библиотеку Soot для работы с Jimple
    - Обеспечивает двусторонние преобразования байткод <-> Jimple

- **MutationStrategy** - определяет конкретные способы изменения кода
    - **BoxingUnboxingMutationStrategy** - добавляет операции упаковки/распаковки
    - **ConditionalRandomWrapperMutationStrategy** - оборачивает код в условия
    - **DeadCodeInsertionMutationStrategy** - вставляет "мертвый" код
    - **ExceptionHandlingMutator** - добавляет обработку исключений
    - **InvertBranchConditionMutator** - инвертирует условия ветвлений
    - **LookupSwitchMutator** - добавляет switch-конструкции
    - **LoopWrapperMutationStrategy** - оборачивает код в циклы
    - **ShuffleStatementsMutationStrategy** - меняет порядок операторов

### 2.4 Измерение производительности
- **Measurer** - запускает и измеряет производительность кода
    - Использует JMH (Java Microbenchmark Harness) для точных измерений
    - Выполняет тесты на различных JVM (HotSpot, OpenJ9, GraalVM)
    - Собирает JIT-логи и метрики производительности

### 2.5 Анализ результатов
- **PerformanceAnalyzer** - анализирует результаты измерений
    - Выявляет статистически значимые различия в производительности
    - Классифицирует аномалии по категориям и степени значимости
    - Интегрируется с JIT-анализом для углубленного понимания

- **JITAnalyzer** - анализирует логи JIT-компиляции
    - Сравнивает профили компиляции разных JVM
    - Определяет "горячие" методы и причины отличий в производительности
    - Оценивает вероятность связи аномалий с JIT-компиляцией

### 2.6 Верификация и хранение аномалий
- **AnomalyVerifier** - подтверждает обнаруженные аномалии
    - Проверяет воспроизводимость аномалий
    - Отсеивает ложноположительные результаты
    - Формирует детальные отчеты по подтвержденным аномалиям

- **AnomalyRepository** - хранит информацию об аномалиях
    - Ведет учет всех обнаруженных и подтвержденных аномалий
    - Категоризирует аномалии по различным признакам
    - Предоставляет интерфейс для работы с накопленными данными

## 3. Процесс обнаружения аномалий (Happy Path)

Диаграмма потока данных

```
                                                                     (Bytecode)
[ByteCodeProvider] --> [Fuzzer] --> [SeedManager] --> [Mutator] -------------------> [JimpleTranslator]
                                          ^                                                 |
                                          |                                                 | (Jimple)
                                          |                               (Bytecode)        v
      [AnomalyRepository] <-- [AnomalyVerifier] <-- [PerformanceAnalyzer] <--------- [MutationStrategy]
                                     ^                        ^
                                     |                        |
                                     +------------------------+
                                                 |
                                                 v
                                             [Measurer]
                                        (JMH, различные JVM)
```

1. **Получение исходного кода**
    - ByteCodeProvider предоставляет начальный байткод (сид)
    - Исходный код может быть получен из .java или .class файлов

2. **Управление сидами и выбор для мутации**
    - SeedManager применяет энергетическо-ценностную модель для выбора сида
    - Учитывается баланс между энергией (ресурс сида) и ценностью (потенциал находок)
    - Выбранный сид передается для мутации, его энергия уменьшается

3. **Фаззинг и мутация**
    - AdaptiveMutator выбирает стратегию мутации, основываясь на предыдущих результатах
    - Исходный байткод преобразуется в Jimple с помощью JimpleTranslator
    - Выбранная MutationStrategy применяется к коду
    - Мутированный код преобразуется обратно в байткод для тестирования

4. **Измерение производительности**
    - Measurer запускает мутированный код на различных JVM с использованием JMH
    - Собираются метрики времени выполнения, использования памяти и другие
    - Параллельно собираются JIT-логи для последующего анализа

5. **Анализ результатов**
    - PerformanceAnalyzer сравнивает метрики производительности между JVM
    - Выявляются статистически значимые отклонения
    - JITAnalyzer исследует логи компиляции для определения причин аномалий
    - Создается детальный профиль аномалии с указанием возможных причин

6. **Верификация и сохранение**
    - AnomalyVerifier проверяет воспроизводимость обнаруженной аномалии
    - Проводятся дополнительные тесты для исключения случайных факторов
    - Подтвержденная аномалия сохраняется в AnomalyRepository
    - Создается отчет с рекомендациями для дальнейшего исследования

7. **Обратная связь в цикл фаззинга**
    - Результаты передаются в SeedManager для обновления ценности сида
    - Если найдена аномалия, SeedManager может создать новый сид на основе мутации
    - Информация о результативности стратегии возвращается в AdaptiveMutator
    - Цикл фаззинга продолжается с учетом накопленного опыта

## 4. Заключение

JVM Performance Fuzzer представляет собой комплексную систему для исследования различий в производительности между JVM. Благодаря интеграции мутационного фаззинга с энергетическо-ценностной моделью эволюции, точных измерений и глубокого анализа JIT-компиляции, инструмент способен автоматически обнаруживать и классифицировать аномалии производительности, предоставляя разработчикам ценную информацию для дальнейших действий.
